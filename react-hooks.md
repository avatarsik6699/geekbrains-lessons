## Теория

React hooks появились в версии React 16.8, они позволяют использовать состояние в функциональном компоненте.
Хуки польностью обратно совместимы, так же можно писать как на классах, так и на хуках

    Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов.
    Хуки не работают внутри классов — они дают вам возможность использовать React без классов.

### Проблемы

- переиспользование логики, в реакт и без хуков можно переиспользовать логику, для этого у него есть два патерна
  рендер-пропсы и компоненты высшего порядка (HOC), эти патерны заставляют изменять структуру компонента, раздувая его
  Но самый яркий минус этих подходов - это огромное кол-во оберток, првоайдеров, консумеров в дев тулзах

С помощью хуков можно извлеч логику из компонента, протестировать и переиспользовать, не изменяя сам компонент

- вторая проблема - это размазанная логика по методам жц
  чаще всего подписки и отписки от методов происходят в componentDidMount/componentWillUnmount, так же нужно обновлять состояние в componentDidUpdate, в итоге
  такой код становится сложнее воспринимать.

хуки позволяют еффективно разбить логику на разные части (используя пользовательские хуки)

- классы более сложны в понимании
  Для работы с классом, нужно понимать , как работает конекст (this), нужно помнить о привязке контекста к обработчикам (классы плохо минифицируются и ломают hot reloading)
  Но у хуков так же есть недостаток, после жц может быть сложным их изучение, так же нужно понимать, как работают замыкания.

### ПроблемыПравила использования хуков

    ✅ Вызывать хуки из функционального компонента React.
    ✅ Вызывать хуки из пользовательского хука.
    ✅ Нельзя вызывать хуки по условию (если нужно условие - переместить его внутрь хука).
    ✅ Желательно называть хуки с приставки use.

Для упрощения работы есть плагин eslint-plugin-react-hooks, который следит за этими правилами

## Обзор хуков

### Хук состояния useState

Один из самых простых, на первый взгляд хуков `useState`.
Хук `useState` принимает один аргумент - начальное состояние (оно может быть абсолютно любым значением) и возвращает массив, первый елемент которого - текущее состояние (обьявляет переменную `count`), а второй - колбек (React гарантирует, что ссылка на него будет ВСЕГДА одна и таже), с помощью которого нужно обновлять состояние (похож на классовый setState) - деструктуризация. Считается хорошей практикой данный обработчик называть с приставкой `set`. Обычно считается, что после выполнения функции - ее локальные переменные удаляются вместе с ней, но тут все не так, потому что React сам следит за этим и сохраняет результаты для каждого компонента отдельно. В одном компоненте можно использовать не ограниченное кол-во хуков. После каждого вызова `setState` React по новой вызывает (обновляет) компонент и каждое следующее обновление уже имеет новое (собственное )состояние, которое является константой внутри нашей функции. Это значит, что ссылка на значение не выполняет никакой привязки данных.

```js
function Foo() {
  const [count, setCount] = useState(0);
}
```

Что бы почитать состояние, достаточно просто обратится к переменной напрямую.

```js
function Foo() {
  const [count, setCount] = useState(0);

  return <p>Текущее значение: {count}</p>;
}
```

Что бы изменить состояние достаточно просто вызвать колбек и передать в него новое состояние. Колбек может принимать или новое значение состояния - или функцию, в которой аргументом будет текущее состояние (это полезно делать - например в еффектах, что бы не было лишних значений в массиве `deps` или что бы обновилять состояние из ребенка без передачи лишнего пропса)

```js
function Foo() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>Текущее значение: {count}</p>
      <button onClick={() => setCount(count + 1)}>setCount</button>
      <button onClick={(state) => setCount(state + 1)}>setCount</button>
    </>
  );
}
```

Стоит обратить внимание, на замыкания, сколько бы раз на вызвали `setCount` - после вызова `handleShowCount` - в консоль будет выведено последнее значения состояния. Такое поведение обьясняется тем, что каждый рендер в React "видит" свое собственное - изолированное состояние. При вызове `setCount` рендер возвращает "новую" версию функции `handleShowCount`, которая ссылается на `count` из текущего рендера.

      Внутри одного рендера - состояние и свойства всега остаются неизменными.

```js
function Foo() {
  const [count, setCount] = useState(0);

  function handleShowCount() {
    setTimeout(() => {
      console.log(count);
    }, 3000);
  }

  return (
    <>
      <p>Текущее значение: {count}</p>
      <button onClick={() => setCount(count + 1)}>setCount</button>
      <button onClick={handleShowCount}>handleShowCount</button>
    </>
  );
}
```

Как мы узнали ранее, в компоненте может быть n- вызовов хуков, каждый хук будет со своим уникалльным состоянием и обработчиком. Данные обработчики можно использвать как напрямую, так и в других обработчиках или передавать дочерним елементам (для изменения состояния из ребенка). Так же в состояние можно передать пропс или колбек, React не будет повторно вызывать функцию переданную ка начальное состояние, ее он вызывает 1 раз при создании компонента.

```js
function Foo() {
  const [age, setAge] = useState(() => 0);

  return (
    <>
      <p>{age}</p>
    </>
  );
}
```

Пример передачи обработчика дочернему компоненту.

```js
function Foo() {
  const [age, setAge] = useState(0);

  return (
    <>
      <p>{age}</p>
      <Children setAge={setAge} />
    </>
  );
}

function Children({ setAge }) {
  return (
    <>
      <button onClick={() => setAge((state) => state + 1)}>
        Обновить возвраст из дочернего компонента
      </button>
    </>
  );
}
```

Множество вызовов хука с различным состоянием.

```js
function Foo() {
  const [age, setAge] = useState(0);
  const [name, setName] = useState("Bogdan");
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => setAge(23)}>setAge</button>
      <button onClick={() => removeFriendByName("Alexandr")}>
        Удалить друга
      </button>
      <input value={name} onChange={({ target }) => setName(target.value)} />
    </>
  );
}
```

В примере выше - хочу обратить внимание на функцию `removeFriendByName`. React всегда смотрит на равенство ссылок, это значит, что из обработчика переданного в `setState` - нужно всегда возвращать новое значение, а не мутировать старое.
Метод `splice` в функции `removeFriendByNameWithMutation` - "мутирует" состояние, это значит, что он оставляет старую ссылку и вырезает елемент у исходного состояния. Если вызвать эту функцию, то React ничего не сделает, ведь он считает, что ссылка осталась старой и не будет выполнять обновление компонента, но состояние БУДЕТ изменено по ссылке. Это легко проверить, достаточно после вызова `removeFriendByNameWithMutation` вызвать `removeFriendByName`, тогда реакт запустит обновление компонента и на екране будет цифра 0. Тут так же стоит сомтреть на то, что возвращается из обработчика, в примере возвращаем не новое состояние, а результат выполнения функции `splice`.

```js
function Foo() {
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  const removeFriendByNameWithMutation = (friendName) => {
    setFriends((state) => {
      const index = state.findIndex((item) => (item.name = friendName));

      state.splice(index, 1);

      // return state.splice(index, 1); // вернет результат выполнения splice

      return state; // вернет мутированное состояние
    });
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => removeFriendByName("Dmitry")}>
        Удалить друга
      </button>
      <button onClick={() => removeFriendByNameWithMutation("Alexandr")}>
        Удалить друга (мутация)
      </button>
    </>
  );
}
```

Так же React довольно "умный", он умеет обьединять вызовы (в рамках одного обработчика) `setState` в один апдейт - `batch`, стоит заметить, что асинхронные вызовы он не сможет сгрупировать.

В примере `Example1` результат вызова `handleUpdateState` будет 100, при этом обновление будет выполнено всего 1 раз (а не 3). Такой результат получился, потому что при первом вызове `setState` - React сохранил его состояние у себя `0 => 0 + 10`, результат 10. Дальше присходит второй вызов, но так, как обновления компонента еще не было, во втором вызове будет старое значение состояния и оно перезатрет предыдущее `() => 0 + 10`, рузультат 10. И финальный вызов так же ссылается на старое состояние `(0 + 100)` и в итоге он перезатрет предыдущий результат и React произведет обновление компонента, вернув последний результат 100.
Во втором примере `handleUpdateAsyncState` - асинхронная функция, при ее вызове - реакт сделает 3 различных обновления, логика будет такой же как и в первом примере и ответ будет 100. Но у React есть способо обойти это ограничение и сделать еденичный апдейт для этого есть функция `ReactDOM.unstable_batchedUpdates`. Вызов функции `handleUpdateAsyncStateWithBatched` вернет одно обновление компонента.

```js
function Example1() {
  const [state, setState] = useState(0);

  const handleUpdateState = () => {
    setState((state) => state + 10);
    setState(() => state + 10);
    setState(state + 100);
  };

  const handleUpdateAsyncState = () => {
    setTimeout(() => {
      setState((state) => state + 10);
      setState(() => state + 10);
      setState(state + 100);
    }, 500);
  };

  const handleUpdateAsyncStateWithBatched = () => {
    setTimeout(() => {
      ReactDOM.unstable_batchedUpdates(() => {
        setState((state) => state + 10);
        setState(() => state + 10);
        setState(state + 100);
      });
    }, 500);
  };

  console.log("update");

  return (
    <>
      <button onClick={handleUpdateState}>Обновить</button>
      <button onClick={handleUpdateAsyncState}>Обновить асинхронно</button>
    </>
  );
}
```

### Хук эффекта useEffect

Хук дает возможность выполнять `side effects (побочные эффекты)` в функциональном компоненте. Побочные эффекты это запросы, изменение DOM, подписки. Данный хук React вызывает `асинхронно`, после того, как применил все изменения в DOM (commit phase). Стоит заметить, что порядок вызова хуков соответствует порядку написания. Что бы лучше понимать еффекты, не нужно смотреть на них как на методы жц, это будет сбивать с толку.

Как же `useEffect` "видит" новую переменную `count` ? Все просто, он так же как и любой другой обрабочик - на каждый рендер "видит" свою собственную переменую, это работает до тех пор, пока мы не забыли добавить `зависимость` в еффект, таким образом еффект предоставлен разными функциями при каждом рендере - и каждая функция еффекта "видит" состояние конкретного рендера. React запоминает функцию еффекта и запускает ее после всех изменений в DOM.

    Грубым примером ожно представить еффект как часть `результата` рендера.

```js
function Foo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log(count);
  });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>setCount</button>
    </>
  );
}
```

Каждый вызов `setCount` запускает свой еффект, который запоминает текущее состояние (замыкание). Но это не работает с изменением исходного состояния по ссылке. (стоит заметить, что это не является ошибкой, иногда такое поведение просто необходимо)

```js
function Foo() {
  const [count, setCount] = useState(0);

  const ref = React.useRef(null);

  useEffect(() => {
    setTimeout(() => {
      console.log(count); // после каждого клика новое значение
    }, 3000);
  });

  useEffect(() => {
    ref.current = count;
    setTimeout(() => {
      console.log(ref.current); // после изменения состояния в консоли будут цифры последнего изменения
    }, 3000);
  });

  return (
    <>
      <button onClick={() => setCount(count + 1)}>setCount</button>
    </>
  );
}
```

Вернемся к подпискам и отпискам. Можно подумать, что при обновлении React сделает очистку для текущего `id`, но это не так, как мы узнали ранее, еффект вызывается `после отрисовки DOM`, это значит, что произойдет подписка с `id = 1`, React отрисует DOM и выполнит еффект, после обновления `id = 2`, React снова обновляет дом, но после этого выполняет `отписку` (колбек, который возвращается из еффекта) c `id = 1` (предыдущее значение) и только после этого выполняет следующий еффект и подписку с новым значением. Тут возникае вопрос - а как еффект видит предыдущее состояние, если уже есть новое? На этот вопросы мы ответили выше:

      Каждая функция "видит" переменные рендера, которые ее определил

```js
useEffect(() => {
  const unsubscribe = api.subscribe(id, cb); // id 1 , 2 тд

  return () => {
    unsubscribe(id, cb); // id 1 , 2 тд
  };
});
```

Что бы не вполнять еффекты постоянно, можно передавать массив зависимостей вторым параметром, если оставить его пустым, это значит, что еффект выполнится только 1 раз при монтировании компонента. Если внутри еффекта используются внешние переменные, нужно всегда передавать их в зависимости, что бы не было различных багов. В примере ниже title будет всегда первым именем и не важно, что само имя изменилось, еффект смотри не на имя, а на переданный массив зависимостей и пропускает выполнение колбека, если они не изменены.

Во втором примере мы снова обманули React и не передали зависимости, многие ожидают тут увидеть увеличение значения `count`, но этого не будет, потому что еффект запомнил результат первого рендера и каждую секунду будет выполнять действие `setCount(0 + 1)`, что бы решить проблему, досаточно передать колбек в `setCount`. Один из способов решить проблемы зависимостей - это использование хука `useReducer` (о нем поговорим ниже).

```js
useEffect(() => {
  document.title = name;
}, []);
```

```js
function Foo() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    const id = setInterval(() => {
      setCount(count + 1);
      // setCount(state => state + 1); // передача колбека решит проблему
    }, 1000);
    return () => clearInterval(id);
  }, []);

  return <>{count}</>;
}
```

Распространенная ошибка думать, что функции не являются зависимостями. В примере еффект не сможет синхронизироавть текущее состояние и вызов функции, одно из решений - перенести обьявление функции в еффект, но все равно нам придется добавить `count` в еффект, иначе он просто не будет вызван.

```js
function Foo() {
  const [count, setCount] = useState(0);

  const foo = () => {
    console.log(count);
  };

  useEffect(() => {
    foo();
  }, []);

  return <>{count}</>;
}
```

Проблема решена? Нет, выше мы узнали, что на каждый рендер создаются новые функции, это значит, если `foo` - не зависит от состояния, она все равно будет пересоздаваться и еффект будет вызван по новой. Как этого избежать? Очень просто, достаточно обернуть функцию в хук `useCallback` (о нем поговорим ниже). useCallback - возвращает старую ссылку и React не выполняет еффект по новой. Но тут так же можно вынести функцию из компонента и передавать параметры через аргументы. (Этот вариант хоорш, ели функция ничего не использует из области видимсости компонента).

```js
// const foo = (params) => {}; она будет создана только 1 раз

function Foo() {
  const [count, setCount] = useState(0);

  const foo = () => {};
  // const foo = useCallback(() => {}, []); // это работает !!

  useEffect(() => {
    foo();
  }, [foo]);

  return <>{count}</>;
}
```

Один из недостатков еффекта, как и работы в классах в целом - является состояние "гонки". Это значит, что я могу запустить еффект два раза с различными значениями и я не знаю, какой результат получу. Тесть при обновлении id - еффект будет запущен второй раз, но запросы выполняются с различной скоростью, результат второго вызова может прийти первым! Это не то, что мы желаем, ведь `count` будет соовершенно другим. Проблему можно решить самым простым флагом обновления. Еффект выполняет колбек "unmount", возвращаемый из него перед следующим рендером, значит предыдущий рузультат не будет записан в состояние.

```js
const Foo = ({ id }) => {
  const [count, setCount] = useState(0);

  useEffect(() => {
    async function fetchCount() {
      const data = await api.call(id);

      setState(data);
    }

    fetchCount();
  }, [id]);

  return <>{count}</>;
};

useEffect(() => {
  let isUpdate = false;

  async function fetchCount() {
    const data = await api.call(id);

    if (!isUpdate) {
      setState(data);
    }
  }

  fetchCount();

  return () => {
    isUpdate = true;
  };
}, [id]);
```

На последок хочу обратить внимание на `порядок` вызова еффектов. Приведем пример компонента:

```js
function App() {
  useEffect(() => {
    console.log("App useEffect");
  }, []);

  console.log("render DOM App");

  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <h2>Start editing to see some magic happen!</h2>
      <Children1 />
      <Children2 />
    </div>
  );
}

function Children1() {
  useEffect(() => {
    console.log("Children1 useEffect");
  }, []);

  console.log("render DOM Children1");

  return (
    <>
      <h1>Children1</h1>;
      <Children3 />
    </>
  );
}

function Children2() {
  useEffect(() => {
    console.log("Children2 useEffect");
  }, []);

  console.log("render DOM Children2");

  return (
    <>
      <h1>Children2</h1>;
    </>
  );
}

function Children3() {
  useEffect(() => {
    console.log("Children3 useEffect");
  }, []);

  console.log("render DOM Children3");

  return (
    <>
      <h1>Children3</h1>;
    </>
  );
}
```

Вы могли подумать, что результат рендера будет следующим, но это не так.

      render DOM App
      App useEffect

      render DOM Children1
      Children1 useEffect

      render DOM Children3
      Children3 useEffect

      render DOM Children2
      Children2 useEffect

Выше мы говорили о том, что еффект вызывается после того, как компонент примонтирован в DOM. Это значит, что компонент `App` не может быть примонтирован раньше, чем `Children1` и тд. (об этом поговорим ниже).
React вызывает компоненты сверху вниз, выполняя еффекты от ребенка к родителю, по завершению `работы` для текущей ноды (завершением работы для ноды считается тот момент, когда у него нет не обработанных дочерних елементов), а если у текущего компонента есть ребенок - он вызывает его и так до конца. (Все еффекты сохраняются в `Effect List`) План работы компонента выше:

- Выполнить render App (есть дочерний компонент), значит не вызываем еффект, идем к дочернему елементу.
- Выполнить render С1 (есть дочерний компонент), значит не вызываем еффект, идем к дочернему елементу.
- Выполнить render С3 (дочернего елемента нет), значит вызываем еффект.
  - Вернуться в C1 и проверить еще дочерние елементы, если нет - вызвать еффект.
- Выполнить render С2 (дочернего елемента нет), значит вызываем еффект.
  - вернуться к родителю App и выполнить его еффект.

Результат выполнения работы `С3 => C1 => C2 => App`.

Не знание этого может привести к багам.

```js
function App() {
  const [list, setList] = useState(null);

  useEffect(() => {
    setList([{ id: "App" }]);
  }, []);

  return (
    <div className="App">
      <Children list={list} setList={setList} />
    </div>
  );
}

const Children = ({ list, setList }) => {
  useEffect(() => {
    setList([{ id: "children" }]);
  }, [setList]);

  // ошибка !
  return (
    <>
      {list.map((item) => (
        <p>{item.id}</p>
      ))}
    </>
  );
};
```

В `Children` мы выводим `list`, но как узнали выше, еффект отработает асинхронно, значит при первом рендере мы будем мапить null, это можно исправить поставив проверку или передав массив как начальное состояние.
Второй момент в том, что в рендер попадет не `id - children`, а `id - app`, потому что еффекты выполняются от ребенка к родителю, об этом стоит не забывать.
