## Теория

React hooks появились в версии React 16.8, они позволяют использовать состояние в функциональном компоненте.
Хуки польностью обратно совместимы, так же можно писать как на классах, так и на хуках

      Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов.
      Хуки не работают внутри классов — они дают вам возможность использовать React без классов.

### Проблемы

-переиспользование логики, в реакт и без хуков можно переиспользовать логику, для этого у него есть два патерна
рендер-пропсы и компоненты высшего порядка (HOC), эти патерны заставляют изменять структуру компонента, раздувая его
Но самый яркий минус этих подходов - это огромное кол-во оберток, првоайдеров, консумеров в дев тулзах

С помощью хуков можно извлеч логику из компонента, протестировать и переиспользовать, не изменяя сам компонент

-вторая проблема - это размазанная логика по методам жц
чаще всего подписки и отписки от методов происходят в componentDidMount/componentWillUnmount, так же нужно обновлять состояние в componentDidUpdate, в итоге
такой код становится сложнее воспринимать.

хуки позволяют еффективно разбить логику на разные части (используя пользовательские хуки)

-классы более сложны в понимании
Для работы с классом, нужно понимать , как работает конекст (this), нужно помнить о привязке контекста к обработчикам (классы плохо минифицируются и ломают hot reloading)
Но у хуков так же есть недостаток, после жц может быть сложным их изучение, так же нужно понимать, как работают замыкания.

### ПроблемыПравила использования хуков

      ✅ Вызывать хуки из функционального компонента React.
      ✅ Вызывать хуки из пользовательского хука.
      ✅ Нельзя вызывать хуки по условию (если нужно условие - переместить его внутрь хука).
      ✅ Желательно называть хуки с приставки use.

Для упрощения работы есть плагин eslint-plugin-react-hooks, который следит за этими правилами

## Обзор хуков

### Хук состояния useState

Один из самых простых, на первый взгляд хуков `useState`.
Хук `useState` принимает один аргумент - начальное состояние (оно может быть абсолютно любым значением) и возвращает массив, первый елемент которого - текущее состояние (обьявляет переменную `count`), а второй - колбек (React гарантирует, что ссылка на него будет ВСЕГДА одна и таже), с помощью которого нужно обновлять состояние (похож на классовый setState) - деструктуризация. Считается хорошей практикой данный обработчик называть с приставкой `set`. Обычно считается, что после выполнения функции - ее локальные переменные удаляются вместе с ней, но тут все не так, потому что React сам следит за этим и сохраняет результаты для каждого компонента отдельно. В одном компоненте можно использовать не ограниченное кол-во хуков.

```js
function Foo() {
  const [count, setCount] = useState(0);
}
```

Что бы почитать состояние, достаточно просто обратится к переменной напрямую.

```js
function Foo() {
  const [count, setCount] = useState(0);

  return <p>Текущее значение: {count}</p>;
}
```

Что бы изменить состояние достаточно просто вызвать колбек и передать в него новое состояние. Колбек может принимать или новое значение состояния - или функцию, в которой аргументом будет текущее состояние (это полезно делать - например в еффектах, что бы не было лишних значений в массиве `deps` или что бы обновилять состояние из ребенка без передачи лишнего пропса)

```js
function Foo() {
  const [count, setCount] = useState(0);

  return (
    <>
      <p>Текущее значение: {count}</p>
      <button onClick={() => setCount(count + 1)}>setCount</button>
      <button onClick={(state) => setCount(state + 1)}>setCount</button>
    </>
  );
}
```

Как мы узнали ранее, в компоненте может быть n- вызовов хуков, каждый хук будет со своим уникалльным состоянием и обработчиком. Данные обработчики можно использвать как напрямую, так и в других обработчиках или передавать дочерним елементам (для изменения состояния из ребенка). Так же в состояние можно передать пропс или колбек, React не будет повторно вызывать функцию переданную ка начальное состояние, ее он вызывает 1 раз при создании компонента.

```js
function Foo() {
  const [age, setAge] = useState(() => 0);

  return (
    <>
      <p>{age}</p>
    </>
  );
}
```

Пример передачи обработчика дочернему компоненту.

```js
function Foo() {
  const [age, setAge] = useState(0);

  return (
    <>
      <p>{age}</p>
      <Children setAge={setAge} />
    </>
  );
}

function Children({ setAge }) {
  return (
    <>
      <button onClick={() => setAge((state) => state + 1)}>
        Обновить возвраст из дочернего компонента
      </button>
    </>
  );
}
```

Множество вызовов хука с различным состоянием.

```js
function Foo() {
  const [age, setAge] = useState(0);
  const [name, setName] = useState("Bogdan");
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => setAge(23)}>setAge</button>
      <button onClick={() => removeFriendByName("Alexandr")}>
        Удалить друга
      </button>
      <input value={name} onChange={({ target }) => setName(target.value)} />
    </>
  );
}
```

В примере выше - хочу обратить внимание на функцию `removeFriendByName`. React всегда смотрит на равенство ссылок, это значит, что из обработчика переданного в `setState` - нужно всегда возвращать новое значение, а не мутировать старое.
Метод `splice` в функции `removeFriendByNameWithMutation` - "мутирует" состояние, это значит, что он оставляет старую ссылку и вырезает елемент у исходного состояния. Если вызвать эту функцию, то React ничего не сделает, ведь он считает, что ссылка осталась старой и не будет выполнять обновление компонента, но состояние БУДЕТ изменено по ссылке. Это легко проверить, достаточно после вызова `removeFriendByNameWithMutation` вызвать `removeFriendByName`, тогда реакт запустит обновление компонента и на екране будет цифра 0. Тут так же стоит сомтреть на то, что возвращается из обработчика, в примере возвращаем не новое состояние, а результат выполнения функции `splice`.

```js
function Foo() {
  const [friends, setFriends] = useState([
    { name: "Alexandr" },
    { name: "Dmitry" },
  ]);

  const removeFriendByName = (friendName) => {
    setFriends((state) => state.filter((friend) => friend.name !== friendName));
  };

  const removeFriendByNameWithMutation = (friendName) => {
    setFriends((state) => {
      const index = state.findIndex((item) => (item.name = friendName));

      state.splice(index, 1);

      // return state.splice(index, 1); // вернет результат выполнения splice

      return state; // вернет мутированное состояние
    });
  };

  return (
    <>
      <p>Количество друзей: {friends.length}</p>
      <button onClick={() => removeFriendByName("Dmitry")}>
        Удалить друга
      </button>
      <button onClick={() => removeFriendByNameWithMutation("Alexandr")}>
        Удалить друга (мутация)
      </button>
    </>
  );
}
```

Так же React довольно "умный", он умеет обьединять вызовы (в рамках одного обработчика) `setState` в один апдейт - `batch`, стоит заметить, что асинхронные вызовы он не сможет сгрупировать.

В примере `Example1` результат вызова `handleUpdateState` будет 100, при этом обновление будет выполнено всего 1 раз (а не 3). Такой результат получился, потому что при первом вызове `setState` - React сохранил его состояние у себя `0 => 0 + 10`, результат 10. Дальше присходит второй вызов, но так, как обновления компонента еще не было, во втором вызове будет старое значение состояния и оно перезатрет предыдущее `() => 0 + 10`, рузультат 10. И финальный вызов так же ссылается на старое состояние `(0 + 100)` и в итоге он перезатрет предыдущий результат и React произведет обновление компонента, вернув последний результат 100.
Во втором примере `handleUpdateAsyncState` - асинхронная функция, при ее вызове - реакт сделает 3 различных обновления, логика будет такой же как и в первом примере и ответ будет 100. Но у React есть способо обойти это ограничение и сделать еденичный апдейт для этого есть функция `ReactDOM.unstable_batchedUpdates`. Вызов функции `handleUpdateAsyncStateWithBatched` вернет одно обновление компонента.

```js
function Example1() {
  const [state, setState] = useState(0);

  const handleUpdateState = () => {
    setState((state) => state + 10);
    setState(() => state + 10);
    setState(state + 100);
  };

  const handleUpdateAsyncState = () => {
    setTimeout(() => {
      setState((state) => state + 10);
      setState(() => state + 10);
      setState(state + 100);
    }, 500);
  };

  const handleUpdateAsyncStateWithBatched = () => {
    setTimeout(() => {
      ReactDOM.unstable_batchedUpdates(() => {
        setState((state) => state + 10);
        setState(() => state + 10);
        setState(state + 100);
      });
    }, 500);
  };

  console.log("update");

  return (
    <>
      <button onClick={handleUpdateState}>Обновить</button>
      <button onClick={handleUpdateAsyncState}>Обновить асинхронно</button>
    </>
  );
}
```
